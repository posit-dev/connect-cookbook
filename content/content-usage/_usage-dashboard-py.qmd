---
title: Content Usage Dashboard
format:
  dashboard:
     theme: default
     orientation: rows
---
<!-- TODO: add code comments
TODO: python code review and cleanup -->

```{python}
#| label: setup
from posit.connect import Client
from datetime import date, timedelta
import os
import sys
import polars as pl
import polars.selectors as cs
import numpy as np
import plotnine as p9
from great_tables import GT, nanoplot_options, style, loc, system_fonts, md


import requests ## TODO can remove this when SDK has usage implementation
```


```{python}
#| label: user-defined inputs 

# 1. specify the guid for the content
# content_guid = "INSERT_CONTENT_GUID" 
content_guid = "0477855b-caeb-43e8-b3d9-28e0965e6230" #shiny
# content_guid = "725e31c7-1588-45bb-95d6-cee508798145" #jupyter

# 2. Specify timeframe for the report. Default is 30 days prior to today
as_of_date = date.today()
days_back = 30

# 3. For by-user summary, specify if the data should truncate to show only the Top N users for the content. Default is `np.nan` for no truncation
top_n = 20
top_n = np.nan

report_from = as_of_date - timedelta(days=days_back)

```


```{python}
#| label: environment variable check

if (
    len(os.getenv("CONNECT_SERVER", "")) == 0
    or len(os.getenv("CONNECT_API_KEY", "")) == 0
):
    sys.stdout.write("The CONNECT_SERVER and CONNECT_API_KEY environment variables are required in order for this report to pull usage data. Please define these variables and then re-run the report.")


headers = {"Authorization": "Key " + os.getenv("CONNECT_API_KEY")} ## TODO can remove this when SDK has usage implementation

```


```{python}
### Establish connection to Connect server
# Note `Client()` automatically detects the environment variables CONNECT_SERVER and CONNECT_API_KEY. They do not need to be specified as arguments to this function, however, if these environment variables are not set, the code will fail
client = Client()

### Determine if the desired content is Shiny or not. This will dictate which telemetry endpoint to use
# Retrieve content details
content_info = client.content.get(content_guid)

# Determine type from the `app_mode`
type = content_info.app_mode

### Query appropriate telemetry endpoint for usage data
if type == "shiny" or type == "python-shiny":

  # Request visit records for the given content GUID
  session = requests.Session()
  session.headers.update({ "Authorization": f"Key {os.getenv("CONNECT_API_KEY")}" })
  session.params.update({
    "content_guid": content_guid,
    "from": report_from.strftime('%Y-%m-%dT%H:%M:%SZ'),
    "to": as_of_date.strftime('%Y-%m-%dT%H:%M:%SZ')
      })
  response = session.get(
      f"{os.getenv("CONNECT_SERVER")}/__api__/v1/instrumentation/shiny/usage"
  )

  # Store all the results and the paging information
  json_data = response.json()
  next_page = json_data['paging']['next']
  usage = pl.DataFrame(json_data['results'])

  # Continue to page through additional records
  # while we have a "next" reference
  while next_page:
    response = session.get(next_page)
    json_data = response.json()
    next_page = json_data['paging']['next']
    results = pl.DataFrame(json_data['results'])
    usage = pl.concat([usage, results])

  
  usage = usage.with_columns(
    pl.col("started").str.to_datetime("%Y-%m-%dT%H:%M:%SZ")
  )
  usage = usage.with_columns(
    pl.col("started").cast(pl.Date).alias("day")
  )
  

else:
  # Request visit records for the given content GUID
  session = requests.Session()
  session.headers.update({ "Authorization": f"Key {os.getenv("CONNECT_API_KEY")}" })
  session.params.update({
    "content_guid": content_guid,
    "from": report_from.strftime('%Y-%m-%dT%H:%M:%SZ'),
    "to": as_of_date.strftime('%Y-%m-%dT%H:%M:%SZ')
      })
  response = session.get(
      f"{os.getenv("CONNECT_SERVER")}/__api__/v1/instrumentation/content/visits"
  )

  # Store all the results and the paging information
  json_data = response.json()
  next_page = json_data['paging']['next']
  usage = pl.DataFrame(json_data['results'])

  # Continue to page through additional records
  # while we have a "next" reference
  while next_page:
    response = session.get(next_page)
    json_data = response.json()
    next_page = json_data['paging']['next']
    results = pl.DataFrame(json_data['results'])
    usage = pl.concat([usage, results])

  usage = usage.with_columns(
    pl.col("time").str.to_datetime("%Y-%m-%dT%H:%M:%SZ")
  )
  usage = usage.with_columns(
    pl.col("time").cast(pl.Date).alias("day")
  )


# ### Fetch all user details to cross reference user_guids with usernames
all_users = pl.DataFrame(client.users.find())

total_visits_in_period = usage.height
unique_visitors = usage.filter(pl.col('user_guid').is_not_null()).select('user_guid').n_unique()



```

## Row



Content usage report for **`{python} content_info.title`**, for the period of **`{python} report_from.strftime('%Y-%m-%d')`** to **`{python} as_of_date.strftime('%Y-%m-%d')`**





## Row 

```{python}
#| content: valuebox
#| title: "Total content visits in period"
#| icon: binoculars
#| color: "success"
dict(
  value = total_visits_in_period
)
```

```{python}
#| content: valuebox
#| title: "Unique viewers in period"
#| icon: people
#| color: "success"
dict(
  value = unique_visitors
)
```


## Row 

```{python}
# plot content visits over time

usage_plot_data = (usage.group_by('day')
                     .agg(pl.len().alias('visits'))
                     .sort('visits', descending=True)
                     .select('day', 'visits')
                     ) 

p9.ggplot(usage_plot_data, p9.aes(x='day', y='visits')) + \
    p9.geom_point(color="#AE929F", size=1) + \
    p9.geom_smooth(se=False, color="#546A7B") + \
    p9.theme_minimal() + \
    p9.labs(y=None, x=None, title="Content visits for " + content_info['title'])



```



```{python}
#| html-table-processing: none
# table content visits by user

# define table title and truncation amount
if np.isnan(top_n):
  title = "Content visits by user"
  # have to define a very high number to feed into `head` below
  truncation_rows = 99999
else:
  title = "Top {} content users".format(top_n)
  truncation_rows = top_n


user_tot_usage = (
  usage.group_by('user_guid')
  .agg(pl.len()
  .alias("tot_visits"))
  .with_columns(pl.coalesce(pl.col('user_guid'), pl.lit('anonymous')).alias('user_guid'))
  
)

user_daily_usage = (
  usage.group_by(['user_guid','day'])
  .agg(pl.len()
  .alias("daily_visits"))
  .join(all_users, left_on='user_guid', right_on='guid', how='left')
  .with_columns(pl.coalesce(pl.col('username'), pl.lit('anonymous')).alias('username'))
  .with_columns(pl.coalesce(pl.col('user_guid'), pl.lit('anonymous')).alias('user_guid'))
  .select(['username', 'user_guid', 'day', 'daily_visits'])
  .sort('day')
  .pivot(index=['username','user_guid'], values='daily_visits', columns='day')
  .join(user_tot_usage, on='user_guid', how='left')
  .sort('tot_visits', descending=True)
  .drop('user_guid')
  .head(truncation_rows)
  .select('username','tot_visits',pl.col("*").exclude('username','tot_visits'))
)

# combine access data into one column list for plotting
nanoplot_columns = user_daily_usage.drop('tot_visits','username').columns

user_daily_usage_concatenated = (user_daily_usage
.fill_null(0)
.with_columns(pl.concat_str([pl.col(nanoplot_columns)], separator=" ").alias('combined'))
.select('username', 'tot_visits', 'combined')
)


(
    GT(user_daily_usage_concatenated, rowname_col="username")
    .tab_header(title=title)
    .tab_stubhead(label="username")
    .cols_label(tot_visits = "total visits")
    .fmt_nanoplot(
      columns="combined",
      autoscale=False,
      options=nanoplot_options(
          show_data_points = False,
          data_area_fill_color = "#CFD9C7",
          data_line_stroke_color = "#546A7B"
      )
    )
)


```


##

```{python}
#| html-table-processing: none
# make a table of content details


wide_info = (
  pl.DataFrame(content_info)
  .select('created_time', 'last_deployed_time', 
          'content_url', 'dashboard_url', 'owner_guid')
  # join with user info table to identify owner username
  .join(all_users.select('guid','username','email'),left_on='owner_guid',right_on='guid', how="left")
  .rename({"username": "content_owner",
          "email": "owner_email"})
  .drop('owner_guid')
  # reorder columns
  .select('content_owner','owner_email',pl.col("*").exclude('content_owner','owner_email'))
  # format the urls TODO: this will be unnecessary when great_tables adds fmt_url. ADD GH Issue link here for tracking
  .with_columns(pl.col(["content_url","dashboard_url"]).apply(lambda x: f"<{x}>"))
  .with_columns(pl.col(["owner_email"]).apply(lambda x: f"[{x}](mailto:{x})"))
  # format dates
  .with_columns(pl.col(['created_time','last_deployed_time']).str.replace(r"T.*", "")
  )


)



long_info = (
  wide_info  
  .melt(value_vars=wide_info.columns, variable_name="item", value_name="value")
)

(
    GT(long_info, rowname_col="item")
    .tab_options(column_labels_hidden=True)
    .tab_style(style=style.text(font="Courier"),locations=loc.body(columns="value"))
    .fmt_markdown(columns="value", rows=['content_url', 'dashboard_url', 'owner_email'])
    .tab_style(style=style.text(decorate="underline"),locations=loc.body(rows=['content_url','dashboard_url','owner_email'], columns="value"))
    
)
# TODO: show nanoplot value as integer. ADD GH issue


  
```

