---
title: Content Usage Dashboard
format:
  dashboard:
     theme: default
     orientation: rows
---
<!-- TODO: add more code comments -->

```{r}
#| label: setup

library(connectapi)
library(tidyverse)
library(gt)
library(plotly)
```


```{r}
#| label: user-defined inputs 

# 1. specify the guid for the content
# content_guid <- "INSERT_CONTENT_GUID" 
content_guid <- "0477855b-caeb-43e8-b3d9-28e0965e6230"

# 2. Specify timeframe for the report. Default is 30 days prior to today
as_of_date <- lubridate::today()
days_back <- 30

# 3. For by-user summary, specify if the data should truncate to show only the Top N users for the content. Default is Inf for no truncation
top_n <- 20

report_from <- as_of_date - lubridate::ddays(days_back)

```


```{r}
#| label: environment variable check

if (
  nchar(Sys.getenv("CONNECT_SERVER")) == 0 ||
  nchar(Sys.getenv("CONNECT_API_KEY")) == 0
){message("The CONNECT_SERVER and CONNECT_API_KEY environment variables are required in order for this report to pull usage data. Please define these variables and then re-run the report.")}

```


```{r}
### Establish connection to Connect server
# Note `connectapi::connect` will automatically detect the environment variables CONNECT_SERVER and CONNECT_API_KEY. They do not need to be specified as arguments to this function, however, if these environment variables are not set, the code will fail
client <- connectapi::connect()

### Determine if the desired content is Shiny or not. This will dictate which telemetry endpoint to use
# Retrieve content details
content_info <- connectapi::get_content(client, guid = content_guid)

# Determine type from the `app_mode`
type <- content_info$app_mode

### Query appropriate telemetry endpoint for usage data
if(type == "shiny" || type == "python-shiny"){
  usage <- connectapi::get_usage_shiny(client, 
                                       content_guid = content_guid, 
                                       from = report_from, 
                                       to = as_of_date,
                                       limit = Inf) |>
            dplyr::mutate(day = lubridate::floor_date(started, "day"))
}else{
  usage <- connectapi::get_usage_static(client, 
                                        content_guid = content_guid, 
                                        from = report_from,
                                        to = as_of_date,
                                        limit = Inf) |>
            dplyr::mutate(day = lubridate::floor_date(time, "day"))
  
}

### Fetch all user details to cross reference user_guids with usernames
all_users <- connectapi::get_users(client, limit = Inf)

total_visits_in_period <- nrow(usage)
unique_visitors <- usage |> filter(!is.na(user_guid)) |>pull(user_guid) |> unique() |> length()

```

## Row



Content usage report for **`r content_info$title`**, for the period of **`r report_from`** to **`r as_of_date`**





## Row 

```{r}
#| content: valuebox
#| title: "Total content visits in period"
#| icon: binoculars
#| color: "success"
list (
  value = total_visits_in_period
)
```

```{r}
#| content: valuebox
#| title: "Unique viewers in period"
#| icon: people
#| color: "success"
list (
  value = unique_visitors
)
```


## Row 
```{r}
#| label: plot content visits over time

usage_plot_data <- usage |>
    group_by(day) |> 
    summarise(visits = n()) |> 
    arrange(desc(visits)) 
  
 
 {ggplot(usage_plot_data, aes(day, visits)) + 
     geom_point(color = "#AE929F", size = 1) +
     geom_smooth(se = FALSE, color = "#546A7B") +
     theme_minimal() +
     labs(
       y = NULL,
       x = NULL,
       title = glue::glue("Content visits for {content_info$title}"),
     )} |> 
      ggplotly(tooltip = c("y")) |> 
      config(displayModeBar = FALSE)


```




```{r}
#| label: table content visits by user
#| html-table-processing: none


usage |> 
  select(user_guid, day) |> 
  group_by(user_guid) |> 
  mutate(tot_visits = n()) |> 
  ungroup() |> 
  group_by(user_guid, day) |> 
  mutate(daily_visits = n()) |> 
  ungroup() |> 
  left_join(all_users, by = c(user_guid = "guid")) |> 
  mutate(username = coalesce(username, "anonymous")) |> 
  select(username, day, tot_visits, daily_visits) |> 
  distinct() |> 
  arrange(desc(tot_visits)) |> 
  pivot_wider(names_from = day, values_from = daily_visits) |> 
  head(top_n) |> 
  gt(rowname_col = "username") |> 
    tab_header(
  title = if(top_n == Inf){
    paste("Content visits by user")
}else{
    paste("Top", top_n, "content users")

})  |> 
    tab_stubhead(label = "username") |> 
    cols_label(tot_visits = "total visits") |> 
    cols_nanoplot(
        columns = -c(tot_visits),
        new_col_name = "daily visits",
        missing_vals = "zero",
        autoscale = FALSE,
        options = nanoplot_options(
          show_data_points = FALSE,
          data_area_fill_color = "#CFD9C7",
            data_line_stroke_color = "#546A7B")
                ) 


```

##

```{r}
#| label: make a table of content details
#| html-table-processing: none



content_info |> 
  select(created_time, last_deployed_time, content_url, dashboard_url, owner_guid) |>
  # join with user info table to identify owner username
  left_join(select(all_users,guid, username, email), by = c(owner_guid = "guid")) |> 
    rename(
      content_owner = username,
      owner_email = email) |> 
    select(-owner_guid) |> 
    relocate(content_owner, owner_email) |> 
   mutate(across(everything(), as.character)) |>
   pivot_longer(everything(), names_to = "item", values_to = "value") |>
    gt(rowname_col = "item") |> 
    tab_options(column_labels.hidden = TRUE) |> 
    tab_style(
  style = cell_text(font = system_fonts("monospace-code")),
  locations = cells_body(columns = value)
  ) |> 
    fmt_url(columns = value, rows = c("dashboard_url", "content_url")) |> 
    fmt_date(columns = value, rows = c("created_time", "last_deployed_time"), date_style = "iso")
  
  
  ```

